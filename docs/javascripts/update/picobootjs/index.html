<!DOCTYPE html>

<html>
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>PicoBootJS</title>
        
    </head>

    <body style="background-color: gray;">
        <button id="click">Button</button>

        <script>

            async function exclusive(device){
                return new Promise(async (resolve, reject) => {
                    let packet = new ArrayBuffer(32);
                    let dataView = new DataView(packet);
                    dataView.setUint32(0x00, 0x431fd10b, true);   // Magic
                    dataView.setUint32(0x04, 0x00000000, true);   // User token

                    dataView.setUint8(0x08, 0x01, true);          // Command ID
                    dataView.setUint8(0x09, 0x01, true);          // Command size
                    dataView.setUint32(0x0c, 0x00000000, true);   // Transfer length

                    dataView.setUint8(0x10, 0x02);                // Exclusive

                    await device.transferOut(3, new Uint8Array(packet));

                    let data = await device.transferIn(4, 64);
                    if(data.status != "ok"){
                        console.error("Could not claim exclusive...");
                        reject();
                    }else{
                        console.log("Wrote exclusive!");
                        resolve();
                    }
                })
            }


            async function reboot(device){
                return new Promise(async (resolve, reject) => {
                    let packet = new ArrayBuffer(32);
                    let dataView = new DataView(packet);
                    dataView.setUint32(0x00, 0x431fd10b, true);   // Magic
                    dataView.setUint32(0x04, 0x00000001, true);   // User token

                    dataView.setUint8(0x08 , 0x02, true);         // Command ID
                    dataView.setUint8(0x09 , 0x0c, true);         // Command size
                    dataView.setUint32(0x0c , 0x00000000, true);  // Transfer length

                    dataView.setUint32(0x10 , 0x00000000, true);  // dPC
                    dataView.setUint32(0x14 , 0x00000000, true);  // dSP
                    dataView.setUint32(0x18 , 0x00005631, true);  // ms Delay (needs to be something other than 0! Copied from Wireshark picotool output)

                    await device.transferOut(3, new Uint8Array(packet));

                    let data = await device.transferIn(4, 64);
                    if(data.status != "ok"){
                        console.error("Could not reboot...");
                        reject();
                    }else{
                        console.log("Wrote reboot!");
                        resolve();
                    }
                })
            }


            async function exitxip(device){
                return new Promise(async (resolve, reject) => {
                    let packet = new ArrayBuffer(32);
                    let dataView = new DataView(packet);
                    dataView.setUint32(0x00, 0x431fd10b, true);   // Magic
                    dataView.setUint32(0x04, 0x00000002, true);   // User token

                    dataView.setUint8(0x08 , 0x06, true);         // Command ID
                    dataView.setUint8(0x09 , 0x00, true);         // Command size
                    dataView.setUint32(0x0c , 0x00000000, true);  // Transfer length

                    await device.transferOut(3, new Uint8Array(packet));

                    let data = await device.transferIn(4, 64);
                    if(data.status != "ok"){
                        console.error("Could not exit xip...");
                        reject();
                    }else{
                        console.log("Wrote exit xip!");
                        resolve();
                    }
                })
            }


            async function flasherase(device, address, size){
                return new Promise(async (resolve, reject) => {
                    let packet = new ArrayBuffer(32);
                    let dataView = new DataView(packet);
                    dataView.setUint32(0x00, 0x431fd10b, true);   // Magic
                    dataView.setUint32(0x04, 0x00000003, true);   // User token

                    dataView.setUint8(0x08 , 0x03, true);         // Command ID
                    dataView.setUint8(0x09 , 0x08, true);         // Command size
                    dataView.setUint32(0x0c , 0x00000000, true);  // Transfer length

                    dataView.setUint32(0x10 , address, true);     // Address
                    dataView.setUint32(0x14 , size, true);        // Size

                    await device.transferOut(3, new Uint8Array(packet));

                    let data = await device.transferIn(4, 64);
                    if(data.status != "ok"){
                        console.error("Could not erase flash...");
                        reject();
                    }else{
                        console.log("Erased", size, "bytes at", address,);
                        resolve();
                    }
                })
            }


            async function flashwrite(device, address, size, payload){
                return new Promise(async (resolve, reject) => {
                    let packet = new ArrayBuffer(32);
                    let dataView = new DataView(packet);
                    dataView.setUint32(0x00, 0x431fd10b, true);   // Magic
                    dataView.setUint32(0x04, 0x00000003, true);   // User token

                    dataView.setUint8(0x08, 0x05, true);          // Command ID
                    dataView.setUint8(0x09, 0x08, true);          // Command size
                    dataView.setUint32(0x0c, size, true);         // Transfer length

                    dataView.setUint32(0x10, address, true);      // Address
                    dataView.setUint32(0x14, size, true);         // Size

                    await device.transferOut(3, new Uint8Array(packet));
                    await device.transferOut(3, new Uint8Array(payload));

                    let data = await device.transferIn(4, 64);
                    if(data.status != "ok"){
                        console.error("Could not write to flash...");
                        reject();
                    }else{
                        console.log("Wrote", size, "bytes to flash starting at", address);
                        resolve();
                    }
                })
            }


            document.getElementById("click").onclick = async (event) => {
                // Setup the device to communicate over PICOBOOT interface and not MSC
                let device = await navigator.usb.requestDevice({ filters: [{vendorId: 0x2E8A, productId: 0x0003}]});
                await device.open();

                if(device.configuration === null){
                    device.setConfiguration(1);
                }

                await device.claimInterface(1);

                // Get USB exclusive control according to the datasheet PICOBOOT interface commands
                await exclusive(device);







                await exitxip(device);

                const flashOffset = 0x10000000;
                const flashSectorSize = 4096;

                const uf2Data = await (await fetch("TinyTV-2-firmware.uf2")).arrayBuffer();
                const uf2BlockSize = 512;
                const uf2BlockCount = uf2Data.byteLength/uf2BlockSize;
                const uf2BlockPayloadSize = 256;
                let uf2Payload = new Uint8Array(flashSectorSize);
                const uf2FlashStartAddress = new DataView(uf2Data.slice(0, uf2BlockSize)).getUint32(12, true);

                for(let ibx=0, ipx=0, flashAddressOffset=0; ibx<uf2BlockCount; ibx++, ipx++){
                    const uf2Offset = ibx*uf2BlockSize;
                    const uf2BlockData = uf2Data.slice(uf2Offset, uf2Offset+uf2BlockSize);
                    const uf2BlockPayload = new Uint8Array(uf2BlockData.slice(32, 32+uf2BlockPayloadSize));

                    uf2Payload.set(uf2BlockPayload, ipx*uf2BlockPayloadSize);

                    if(ipx+1 == (flashSectorSize/uf2BlockPayloadSize) || ibx+1 == uf2BlockCount){
                        await flasherase(device, uf2FlashStartAddress+flashAddressOffset, flashSectorSize);
                        await flashwrite(device, uf2FlashStartAddress+flashAddressOffset, flashSectorSize, uf2Payload);
                        uf2Payload = new Uint8Array(flashSectorSize);
                        ipx = -1;
                        flashAddressOffset += flashSectorSize;
                    }
                }

                console.warn("Done flashing firmware!");
                await reboot(device);
            }
        </script>
    </body>
</html>